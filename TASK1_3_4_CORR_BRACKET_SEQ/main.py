# Задание решено по видеоурокам:
# https://www.youtube.com/watch?v=YFqfxxxfELU
# https://www.youtube.com/watch?v=OTudUhiLNvk
# https://www.youtube.com/watch?v=lNi59Um0_rA
# https://www.youtube.com/watch?v=aWpE_JvRbnA
# https://www.youtube.com/watch?v=YFqfxxxfELU
#
# Алгоритм решения с помощью стека LIFO
# Вход - строка s из скобок. По условию гарантируется, что введенная строка X будет содержать только скобки и не будет пустой.
# В цикле перебираем все символы строки s слева напараво.
# 1. Открывающие скобки складываем в стек
# 2. Если встретилась закрывающая скобка - достаем из стека последнюю открывающую скобку и сравниваем с закрывающей.
# 3. Если скобки не совпадают - выход, результат False - скобочная последовательность неправильная
# 4. Если скобки совпадают - продолжаем перебирать строку.
# 5. Если все открывающие и закрывающие скобки совпали - проверяем, что стек пуст.
# 6. Если стек пуст - возвращаем True, скобочная последовательность правильная. Если нет - False
#

str = input()  # проверяемая строка


def is_bracket_seq_correct(str):
    is_bracket_seq_correct = True
    stack = []  # стек для открывающих скобок
    # проверка, что введённая строка не пустая
    if str == '':
        # пустая строка тоже правильная скобочная последовательность!
        is_bracket_seq_correct = True
    for s in str:  # перебор по всем символам из str
        if s in '([{':  # если текущий символ исходной строки открывающая скобка
            stack.append(s)  # помещаем её в стек
        elif s in ')]}':  # иначе, если текущий символ закрывающая скобка
            # проверяем, что стэк не пустой (для случая, когда закрывающих скобок больше открывающих)
            # или, что в стеке не осталось открывающих скобок (для случая, когда открывающих скобок больше закрывающих)
            if not stack:
                is_bracket_seq_correct = False
                break
            # извлекаем последнюю открывающую скобку из стека и сравниваем с ней текущий символ
            open_bracket = stack.pop()
            # если октрывающая скобка из стека соответствует текущей закрывающей
            if open_bracket == '(' and s == ')':
                continue  # то продолжаем цикл
            if open_bracket == '[' and s == ']':
                continue
            if open_bracket == '{' and s == '}':
                continue
            is_bracket_seq_correct = False
            break
    if is_bracket_seq_correct == True and len(stack) == 0:
        return True
    else:
        return False


print(is_bracket_seq_correct(str))
